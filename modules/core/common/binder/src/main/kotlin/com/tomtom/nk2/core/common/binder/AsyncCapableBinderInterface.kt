/*
 * Copyright (c) 2020 - 2020 TomTom N.V. All rights reserved.
 *
 * This software is the proprietary copyright of TomTom N.V. and its subsidiaries and may be
 * used for internal evaluation purposes or commercial use strictly subject to separate
 * licensee agreement between you and TomTom. If you are the licensee, you are only permitted
 * to use this Software in accordance with the terms of your license agreement. If you are
 * not the licensee then you are not authorised to use this software in any manner and should
 * immediately return it to TomTom N.V.
 */

package com.tomtom.nk2.core.common.binder

import android.os.Binder
import android.os.IBinder
import android.os.IInterface
import android.os.Parcel
import kotlinx.coroutines.CoroutineScope

/**
 * Base interface for [IBinder] interfaces that require async replies.
 *
 * See [AsyncReplyReceiver] for details.
 *
 * The binder `Stub` class of derived interfaces should use [AsyncCapableBinderInterface.Stub] as
 * its superclass and the binder `Proxy` should use [AsyncCapableBinderInterface.Proxy] as its
 * superclass. These classes provide the binder interface the ability to send async replies through
 * the [AsyncReplyReceiver] class.
 *
 * The `Stub` and `Proxy` classes of derived interfaces should use [FIRST_CALL_TRANSACTION]
 * for the first binder transaction code (instead of [IBinder.FIRST_CALL_TRANSACTION]).
 *
 * The `aidl` tool is not used as it doesn't support Kotlin coroutines. The inner classes follow
 * as much as possible the structure of the code generated by the `aidl` tool.
 */
interface AsyncCapableBinderInterface : IInterface {

    fun removeAsyncReplyReceiver()

    abstract class Stub(
        private val killableLifecycleOwner: KillableLifecycleOwner,
        private val coroutineScope: CoroutineScope
    ) : Binder(),
        AsyncCapableBinderInterface {
        protected var asyncReplyReceiver: AsyncReplyReceiver? = null

        override fun onTransact(code: Int, data: Parcel, reply: Parcel?, flags: Int): Boolean {
            when (code) {
                TRANSACTION_SET_ASYNC_REPLY_RECEIVER -> {
                    data.enforceInterface(DESCRIPTOR)
                    asyncReplyReceiver =
                        AsyncReplyReceiver.Stub.Proxy(
                            data.readStrongBinder(),
                            killableLifecycleOwner,
                            coroutineScope
                        )
                    /** Caller expects [reply]. */
                    reply!!.writeNoException()
                    return true
                }
                TRANSACTION_REMOVE_ASYNC_REPLY_RECEIVER -> {
                    data.enforceInterface(DESCRIPTOR)
                    removeAsyncReplyReceiver()
                    /** Caller expects [reply]. */
                    reply!!.writeNoException()
                    return true
                }
            }
            return super.onTransact(code, data, reply, flags)
        }

        override fun removeAsyncReplyReceiver() {
            asyncReplyReceiver = null
        }
    }

    abstract class Proxy(protected val remote: IBinder) : AsyncCapableBinderInterface {
        protected val asyncReplyReceiver: AsyncReplyReceiver.Stub by lazy {
            AsyncReplyReceiver.Stub()
        }

        protected fun setupAsyncReplyReceiver() {
            val data = Parcel.obtain()
            val reply = Parcel.obtain()
            try {
                data.writeInterfaceToken(DESCRIPTOR)
                data.writeStrongBinder(asyncReplyReceiver.asBinder())
                remote.transact(TRANSACTION_SET_ASYNC_REPLY_RECEIVER, data, reply, 0)
                reply.readException()
            } finally {
                reply.recycle()
                data.recycle()
            }
        }

        override fun removeAsyncReplyReceiver() {
            val data = Parcel.obtain()
            val reply = Parcel.obtain()
            try {
                data.writeInterfaceToken(DESCRIPTOR)
                remote.transact(TRANSACTION_REMOVE_ASYNC_REPLY_RECEIVER, data, reply, 0)
                reply.readException()
            } finally {
                reply.recycle()
                data.recycle()
            }
        }
    }

    companion object {
        private const val DESCRIPTOR =
            "com.tomtom.nk2.core.common.binder.AsyncCapableBinderInterface"

        private const val TRANSACTION_SET_ASYNC_REPLY_RECEIVER =
            IBinder.FIRST_CALL_TRANSACTION + 0

        private const val TRANSACTION_REMOVE_ASYNC_REPLY_RECEIVER =
            IBinder.FIRST_CALL_TRANSACTION + 1

        const val FIRST_CALL_TRANSACTION = TRANSACTION_REMOVE_ASYNC_REPLY_RECEIVER + 1
    }
}
