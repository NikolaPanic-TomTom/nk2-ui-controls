/*
 * Copyright (c) 2020 - 2020 TomTom N.V. All rights reserved.
 *
 * This software is the proprietary copyright of TomTom N.V. and its subsidiaries and may be
 * used for internal evaluation purposes or commercial use strictly subject to separate
 * licensee agreement between you and TomTom. If you are the licensee, you are only permitted
 * to use this Software in accordance with the terms of your license agreement. If you are
 * not the licensee then you are not authorised to use this software in any manner and should
 * immediately return it to TomTom N.V.
 */

package com.tomtom.nk2.core.common.binder

import android.os.Binder
import android.os.IBinder
import android.os.IInterface
import android.os.Parcel
import com.tomtom.nk2.core.common.binder.AsyncReplyReceiver.Stub
import kotlin.coroutines.Continuation
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine

/**
 * Receives replies asynchronously over an [IBinder] interface.
 *
 * Normally, [IBinder] interfaces are synchronous. The calling thread is blocked until a reply is
 * received. To allow suspendable functions in IVI services, the replies of suspendable functions
 * should not block the calling thread. As such, the generated code uses this class to send the
 * replies back asynchronously.
 *
 * On the client side, the coroutine is suspended until the async reply is retrieved.
 * On the server side, a coroutine is launched and the calling binder call is returned directly.
 * When the launched coroutine returns, the async reply is send to the client.
 *
 * Only the [Stub.Proxy] (on the server side) implements this interface. The [Stub] (on the client
 * side) provides a [Stub.sendAndWaitForReply] instead as a utility function to send a message and
 * wait for the reply asynchronously.
 *
 * The `aidl` tool is not used as it doesn't support Kotlin coroutines. The inner classes follow
 * as much as possible the structure of the code generated by the `aidl` tool.
 */
interface AsyncReplyReceiver : IInterface {

    /**
     * Invokes a suspendable [replyProvider] and sends the reply asynchronously.
     *
     * The [replyProvider] can write the reply to the given [Parcel] instance. The parcel is
     * sent to the client once the [replyProvider] returns.
     *
     * @param requestId The request ID of the request to reply to.
     * @param replyProvider The reply provider to invoke.
     */
    fun launchAndReply(requestId: RegistrationToken, replyProvider: suspend (Parcel) -> Unit)

    private class AsyncReplyHandler<T>(
        private val replyHandler: (Parcel) -> T,
        private val cont: Continuation<T>
    ) {
        fun onReply(data: Parcel) {
            try {
                data.readException()
            } catch (e: Exception) {
                cont.resumeWithException(e)
                return
            }
            cont.resume(replyHandler(data))
        }
    }

    /**
     * Used by the clients to send messages over the binder interface and to receive an
     * asynchronous reply back.
     *
     * @note This Stub actually does not implement the [AsyncReplyReceiver] interface. Use
     *     [sendAndWaitForReply] instead.
     */
    class Stub : Binder() {
        private val pendingReplies = RegistrationTokenMap<AsyncReplyHandler<*>>()

        /**
         * Utility function allowing clients to send a parcel to a server and wait for
         * asynchronously reply.
         *
         * The utility function suspends the coroutine until the asynchronous reply
         * is received.
         *
         * Note, any binder transaction is synchronous by nature. Therefore this function also
         * checks the synchronous reply.
         *
         * @param T The return type of the calling coroutine function.
         * @param block Invoked to add data to the parcel and perform a normal binder transaction.
         * @param replyHandler Invoked after the asynchronous reply is received.
         * @return The asynchronous reply.
         */
        suspend fun <T> sendAndWaitForReply(
            descriptor: String,
            block: (Parcel, Parcel) -> Unit,
            replyHandler: (Parcel) -> T
        ): T {
            return waitForReply(replyHandler) { requestId ->
                val data = Parcel.obtain()
                val reply = Parcel.obtain()
                try {
                    data.writeInterfaceToken(descriptor)
                    data.writeParcelable(requestId, 0)
                    block(data, reply)
                    reply.readException()
                } finally {
                    reply.recycle()
                    data.recycle()
                }
            }
        }

        private suspend fun <T> waitForReply(
            replayHandler: (Parcel) -> T,
            block: (RegistrationToken) -> Unit
        ): T {
            val requestId = pendingReplies.getNewToken()
            try {
                return suspendCancellableCoroutine { cont ->
                    pendingReplies.setTokenEntry(requestId, AsyncReplyHandler(replayHandler, cont))
                    try {
                        block(requestId)
                    } catch (e: Exception) {
                        cont.resumeWithException(e)
                    }
                }
            } finally {
                pendingReplies.removeTokenEntry(requestId)
            }
        }

        private fun onReplyReceived(requestId: RegistrationToken, data: Parcel) {
            val entry = pendingReplies.getTokenEntry(requestId)
            entry?.onReply(data)
        }

        fun asBinder() = this

        override fun onTransact(code: Int, data: Parcel, reply: Parcel?, flags: Int): Boolean {
            when (code) {
                IBinder.INTERFACE_TRANSACTION -> {
                    /** Caller expects [reply]. */
                    reply!!.writeString(DESCRIPTOR)
                    return true
                }
                TRANSACTION_ON_REPLY -> {
                    data.enforceInterface(DESCRIPTOR)
                    val requestId =
                        data.readParcelable<RegistrationToken>(Stub::class.java.classLoader)!!
                    onReplyReceived(requestId, data)
                    return true
                }
            }
            return super.onTransact(code, data, reply, flags)
        }

        /**
         * Used by servers to launch a coroutine and asynchronously send a reply back.
         */
        class Proxy(
            private val remote: IBinder,
            private val killableLifecycleOwner: KillableLifecycleOwner,
            private val coroutineScope: CoroutineScope
        ) : AsyncReplyReceiver {
            override fun asBinder(): IBinder = remote

            override fun launchAndReply(
                requestId: RegistrationToken,
                replyProvider: suspend (Parcel) -> Unit
            ) {
                coroutineScope.launch {
                    val data = Parcel.obtain()
                    try {
                        data.writeInterfaceToken(DESCRIPTOR)
                        data.writeParcelable(requestId, 0)
                        data.writeNoException()
                        try {
                            replyProvider(data)
                        } catch (e: Exception) {
                            data.setDataPosition(0)
                            data.writeInterfaceToken(DESCRIPTOR)
                            data.writeParcelable(requestId, 0)
                            data.writeException(e)
                        }
                        killableLifecycleOwner.invokeDeathSafe {
                            remote.transact(TRANSACTION_ON_REPLY, data, null, IBinder.FLAG_ONEWAY)
                        }
                    } finally {
                        data.recycle()
                    }
                }
            }
        }

        companion object {
            private const val DESCRIPTOR = "com.tomtom.nk2.core.common.binder.AsyncReplyReceiver"

            private const val TRANSACTION_ON_REPLY = IBinder.FIRST_CALL_TRANSACTION + 0
        }
    }
}
